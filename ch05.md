# 05 배열과 튜플

# 05-1 배열 이해하기

Array 클래스의 인스턴스이며 다음처럼 선언.

```javascript
let 배열이름 = new Array(배열길이)
```

```typescript
let array = new Array
array.push(1); array.push(2); array.push(3)
console.log(array)
```

## [] 단축 구문

```typescript
let numbers = [1, 2, 3]
let strings = ['Hello', 'World']
console.log(numbers, strings)
```

## 자바스크립트에서 배열은 객체다

배열은 Array 클래스의 인스턴스인데, 클래스의 인스턴스는 객체이기 때문에 객체임.
**Array.isArray**는 매개변수로 전달받은 심벌이 배열인지 객체인지 알려줌.

```typescript
let a = [1, 2, 3]
let o = {name: 'Jack', age: 32}
console.log(Array.isArray(a), Array.isArray(o)) // true false
```

## 배열의 타입

타입스크립트에서 배열의 타입은 **아이템타입[]**임.

```typescript
let numArray: number[] = [1,2,3]
let strArray: string[] = ['Hello','World']

type IPerson = {name: string, age?: number}
let personArray: IPerson[] = [{name: 'John'}, {name: 'Jane', age: 32}]
```

## 문자열과 배열 간 변환

어떤 프로그래밍 언어는 문자열을 문자들의 배열로 간주함.
그러나 타입스크립트에서는 문자 타입이 없고 문자열의 내용 또한 변경 불가.
이런 특징때문에 문자열을 가공하려면 먼저 문자열을 배열로 전환해야 함.

보통 문자열을 배열로 전환할 때 String 클래스의 split메서드 사용

```typescript
split(구분자: string): string[]
```

```typescript
export const split = (str: string, delim: string=''): string[] => str.split(delim)
```

```typescript
import { split } from "./split";
console.log(
  split('hello'), 
  split('h_e_l_l_o','_')
)
```

string[] 타입의 배열을 다시 string 타입으로 변환하려면 Array 클래스의 join 메서드를 사용.

```typescript
join(구분자: string): string
```

```typescript
export const join = (strArray: string[], delim: string=''): string => strArray.join(delim)
```

```typescript
import { join } from "./join";
console.log(
  join(['h','e','l','l','o']),
  join(['h','e','l','l','o'], '_')
)
```

## 인덱스 연산자

**numbers[index]** 형태로 배열의 특정 위치에 담긴 값을 얻음

```typescript
const numbers: number[] = [1, 2, 3, 4, 5]

for(let index = 0; index < numbers.length; index++){
  const item: number = numbers[index]
  console.log(item)
}
```

## 배열의 비구조화 할당

배열에도 비구조화 할당 적용 가능.

```typescript
let array: number[] = [1, 2, 3, 4, 5]
let [first, second, third, ...rest] = array
console.log(first, second, third, rest)
```

## for ... in 문

```typescript
fot(변수 in 객체){

}
```
```typescript
let names = ['Jack', 'John', 'Mary', 'Chris']

for(let index in names){
  const name = names[index]
  console.log(`[${index}]: ${name}`)
}
```

객체를 사용할 때
```typescript
let jack = {name: 'Jack', age: 32}
for (let property in jack) {
  console.log(`${property}: ${jack[property]}`)
}
```

## for ...of 문

```typescript
for(let 변수 of 객체){

}
```

```typescript
for(let name of ['Jack', 'John', 'James'])
  console.log(name)
```

## 제네릭 방식 타입

배열을 다루는 함수를 작성할 때 number[]와 같이 타입이 고정된 함수를 만들기보다는 T[]형태로 배열의 아이템 타입을 한꺼번에 표현하는 것이 편리.
타입을 T와 같은 일종의 변수(타입변수)로 취급하는 것을 제네릭타입이라고 함.

```typescript
const arrayLength = (array) => array.length
```

```typescript
const arrayLength = (array: T[]): number => array.length
```

```typescript
export const arrayLength = <T>(array: T[]): number => array.length
export const isEmpty = <T>(array: T[]): boolean => arrayLength<T>(array) == 0
```

```typescript
import { arrayLength, isEmpty } from "./arrayLength";

let numArray: number[] = [1, 2, 3]
let strArray: string[] = ['Hello', 'World']

type IPerson = {name: string, age?: number}
let personArray: IPerson[] = [{name: 'John'}, {name: 'Tom', age:32}]

console.log(
  arrayLength(numArray),
  arrayLength(strArray),
  arrayLength(personArray),
  isEmpty([]),
  isEmpty([1])
)
```

## 제네릭 함수의 타입 추론

```typescript
함수이름<타입변수>(매개변수)
```

```typescript
const identity = <T>(n : T): T => n
console.log(
  identity<boolean>(true),
  identity(true)
)
```

## 전개 연산자

```typescript
let array1: number[] = [1]
let array2: number[] = [2, 3]
let mergedArray: number[] = [...array1, ...array2, 4]
console.log(mergedArray)
```

## range 함수 구현

range 함수는 재귀 함수(recursive function)스타일로 동작하며, R.range처럼 from에서 to까지 수로 구성된 배열을 생성함.

```typescript
export const range = (from: number, to: number): number => from < to? [from, ...range(from + 1, to)]: []
```

```typescript
import { range } from "./range";
let numbers: number[] = range(1, 9 + 1)
console.log(numbers)
```


# 05-2 선언형 프로그래밍과 배열

함수형 프로그래밍은 선언형 프로그래밍과 깊은 관련이 있음.
배열은 선언형 프로그래밍을 구현할 때 절대적으로 필요한 문법 기능.
명령형은 좀 더 CPU 친화적인 저수준 구현 방식아고, 선언형은 명형형 방식 위에서 동작하는 인간에게 더 친화적인 고수준 구현 방식.

## 명령형 프로그래밍이란?
프로그램의 기본 형태는 입력 데이터를 얻고 가공한 다음, 결과를 출력하는 형태로 구성.

- 입력 데이터 얻기
- 입력 데이터 가공해 출력 데이터 생성
- 출력 데이터 출력

명령형 프로그래밍에서는 여러 개의 데이터를 대상으로 할 때 for문을 사용해 구현.

```typescript
for( ; ; ){
  입력 데이터 얻기
  입력 데이터 가공해 출력 데이터 생성
  출력 데이터 출력
}
```

## 선언형 프로그래밍

시스템 자원의 효율적인 운용보다는 일관된 문제 해결 구조에 더 집중.
모든 데이터를 배열에 담음. 그리고 문제가 해결될 때까지는 끊임없이 또 다른 형태의 배열로 가공하는 방식으로 구현.

- 문제를 푸는 데 필요한 모든 데이터 배열에 저장
- 입력 데이터 배열을 가공해 출력 데이터 배열 생성
- 출력 데이터 배열에 담긴 아이템 출력

## 1부터 100까지 더하기 문제 풀이

### 명령형 프로그래밍 방식 
```typescript
let sum = 0
for(let val = 1; val <= 100;)
  sum += val++
console.log(sum)
```

### 선언형 프로그래밍
```typescript
import { range } from "./range";

let numbers: number[] = range(1, 100+1)
console.log(numbers)
```
ch05-1 range 활용, 1~100까지 배열에 저장
배열에 담긴 데이터를 모두 더해야함. 
이와 같은 방식의 데이터 가공은 함수형 프로그래밍에서 흔히 만날 수 있는 '폴드'라고 부르는 함수를 사용

## fold: 배열 데이터 접기

폴드 함수의 동작 방식은 마치 부채처럼 배열을 펼쳐놓은 다음, 부채를 접어서 결과를 만들어 내는 것을 생각할 수 있음.

```typescript
export const fold = <T>(array: T[], callback: (result: T, val: T) => T, initValue: T) => {
  let result: T = initValue
  for(let i = 0; i < array.length; ++i) {
    const value = array[i]
    result = callback(result, value)
  }
  return result
}
```

## 1에서 100까지 홀수의 합 구하기

### 명령형 프로그래밍

```typescript
let oddSum = 0
for (let val = 1; val <= 100; val += 2){
  oddSum += val
}
console.log(oddSum)
```

## fliter: 조건에 맞는 아이템만 추려내기

```typescript
export const filter = <T>(array: T[], callback: (value: T, index?: number) => boolean): T[] => {
   let result: T[] = []
   for (let index = 0; index < array.length; ++index) {
      const value = array[index]
      if(callback(value, index))
        result = [...result, value]
   }
   return result
}
```

```typescript
import { range } from "./range";
import { fold } from "./fold";
import { filter } from "./fliter";

let numbers: number[] = range(1, 100+1)
const isOdd = (n: number): boolean => n % 2 != 0
let result = fold(filter(numbers, isOdd), (result, value) => result + value, 0)
console.log(result)
```

## 1에서 100까지 짝수의 함 구하기

### 명령형

```typescript
let evenSum = 0
for (let val = 0; val <= 100; val += 2){
  evenSum += val
}
console.log(evenSum)
```

```typescript
import { range } from "./range";
import { fold } from "./fold";
import { filter } from "./fliter";

let numbers: number[] = range(1, 100+1)
const isEven = (n: number): boolean => n % 2 == 0
let result = fold(filter(numbers, isEven), (result, value) => result + value, 0)
console.log(result)
```
## 1에서 100 각각 제곱 더하기

### 명령형

```typescript
let squareSum = 0
for (let val = 0; val <= 100; val += 2){
  squareSum += val * val
}
console.log(squareSum)
```

## map: 배열 데이터 가공하기

```typescript
export const map = <T, Q>(array: T[], callback: (value: T, index?: number) => Q): Q[] => {
  let result: Q[] = []
  for(let index = 0; index < array.length; ++index) {
    const value = array[index]
    result = [...result, callback(value, index)]
  }
  return result
}
```

```typescript
import { range } from "./range";
import { fold } from "./fold";
import { map } from "./map";

let numbers: number[] = range(1, 100+1)
let result = fold(map(numbers, value => value * value), (result, value) => result + value, 0)
console.log(result)
```

# 배열의 map, reduce, fliter 메서드

## 메서드 체인 방식

```typescript
const multiply = (result, val) => result * val

let numbers: number[] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
let tempResult = numbers
  .filter(val => val % 2 != 0)
  .map(val => val * val)
  .reduce(multiply, 1)
let result = Math.round(Math.sqrt(tempResult))
console.log(result)
```

## filter 메서드

```typescript
filter(callback: (value: T, index?:number): boolean): T[]
```


## map 메서드

```typescript
map(callback: (value: T, index?:number): Q): Q[]
```

## reduce 메서드 

앞서 05-2절에서 구현한 fold 함수는 타입스크립트 배열의 reduce 메서드로 대체 가능.

```typescript
reduce(callback: (result: T, value: T), initialValue: T): T
```
```typescript
import { range } from './range'

let reduceSum: number = range(1, 100+1)
  .reduce((result: number, value: number) => result + value, 0)
console.log(reduceSum)
```


```typescript
import { range } from './range'

let reduceSum: number = range(1, 100+1)
  .reduce((result: number, value: number) => result * vlue, 1)
console.log(reduceSum)
```

