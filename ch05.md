# 05 배열과 튜플

# 05-1 배열 이해하기

Array 클래스의 인스턴스이며 다음처럼 선언.

```javascript
let 배열이름 = new Array(배열길이)
```

```typescript
let array = new Array
array.push(1); array.push(2); array.push(3)
console.log(array)
```

## [] 단축 구문

```typescript
let numbers = [1, 2, 3]
let strings = ['Hello', 'World']
console.log(numbers, strings)
```

## 자바스크립트에서 배열은 객체다

배열은 Array 클래스의 인스턴스인데, 클래스의 인스턴스는 객체이기 때문에 객체임.
**Array.isArray**는 매개변수로 전달받은 심벌이 배열인지 객체인지 알려줌.

```typescript
let a = [1, 2, 3]
let o = {name: 'Jack', age: 32}
console.log(Array.isArray(a), Array.isArray(o)) // true false
```

## 배열의 타입

타입스크립트에서 배열의 타입은 **아이템타입[]**임.

```typescript
let numArray: number[] = [1,2,3]
let strArray: string[] = ['Hello','World']

type IPerson = {name: string, age?: number}
let personArray: IPerson[] = [{name: 'John'}, {name: 'Jane', age: 32}]
```

## 문자열과 배열 간 변환

어떤 프로그래밍 언어는 문자열을 문자들의 배열로 간주함.
그러나 타입스크립트에서는 문자 타입이 없고 문자열의 내용 또한 변경 불가.
이런 특징때문에 문자열을 가공하려면 먼저 문자열을 배열로 전환해야 함.

보통 문자열을 배열로 전환할 때 String 클래스의 split메서드 사용

```typescript
split(구분자: string): string[]
```

```typescript
export const split = (str: string, delim: string=''): string[] => str.split(delim)
```

```typescript
import { split } from "./split";
console.log(
  split('hello'), 
  split('h_e_l_l_o','_')
)
```

string[] 타입의 배열을 다시 string 타입으로 변환하려면 Array 클래스의 join 메서드를 사용.

```typescript
join(구분자: string): string
```

```typescript
export const join = (strArray: string[], delim: string=''): string => strArray.join(delim)
```

```typescript
import { join } from "./join";
console.log(
  join(['h','e','l','l','o']),
  join(['h','e','l','l','o'], '_')
)
```

## 인덱스 연산자

**numbers[index]** 형태로 배열의 특정 위치에 담긴 값을 얻음

```typescript
const numbers: number[] = [1, 2, 3, 4, 5]

for(let index = 0; index < numbers.length; index++){
  const item: number = numbers[index]
  console.log(item)
}
```

## 배열의 비구조화 할당

배열에도 비구조화 할당 적용 가능.

```typescript
let array: number[] = [1, 2, 3, 4, 5]
let [first, second, third, ...rest] = array
console.log(first, second, third, rest)
```

## for ... in 문

```typescript
fot(변수 in 객체){

}
```
```typescript
let names = ['Jack', 'John', 'Mary', 'Chris']

for(let index in names){
  const name = names[index]
  console.log(`[${index}]: ${name}`)
}
```

객체를 사용할 때
```typescript
let jack = {name: 'Jack', age: 32}
for (let property in jack) {
  console.log(`${property}: ${jack[property]}`)
}
```

## for ...of 문

```typescript
for(let 변수 of 객체){

}
```

```typescript
for(let name of ['Jack', 'John', 'James'])
  console.log(name)
```

## 제네릭 방식 타입

배열을 다루는 함수를 작성할 때 number[]와 같이 타입이 고정된 함수를 만들기보다는 T[]형태로 배열의 아이템 타입을 한꺼번에 표현하는 것이 편리.
타입을 T와 같은 일종의 변수(타입변수)로 취급하는 것을 제네릭타입이라고 함.

```typescript
const arrayLength = (array) => array.length
```

```typescript
const arrayLength = (array: T[]): number => array.length
```

```typescript
export const arrayLength = <T>(array: T[]): number => array.length
export const isEmpty = <T>(array: T[]): boolean => arrayLength<T>(array) == 0
```

```typescript
import { arrayLength, isEmpty } from "./arrayLength";

let numArray: number[] = [1, 2, 3]
let strArray: string[] = ['Hello', 'World']

type IPerson = {name: string, age?: number}
let personArray: IPerson[] = [{name: 'John'}, {name: 'Tom', age:32}]

console.log(
  arrayLength(numArray),
  arrayLength(strArray),
  arrayLength(personArray),
  isEmpty([]),
  isEmpty([1])
)
```

## 제네릭 함수의 타입 추론

```typescript
함수이름<타입변수>(매개변수)
```

```typescript
const identity = <T>(n : T): T => n
console.log(
  identity<boolean>(true),
  identity(true)
)
```

## 전개 연산자

```typescript
let array1: number[] = [1]
let array2: number[] = [2, 3]
let mergedArray: number[] = [...array1, ...array2, 4]
console.log(mergedArray)
```

## range 함수 구현

range 함수는 재귀 함수(recursive function)스타일로 동작하며, R.range처럼 from에서 to까지 수로 구성된 배열을 생성함.

```typescript
export const range = (from: number, to: number): number => from < to? [from, ...range(from + 1, to)]: []
```

```typescript
import { range } from "./range";
let numbers: number[] = range(1, 9 + 1)
console.log(numbers)
```





